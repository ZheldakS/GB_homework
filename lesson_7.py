# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц: 3 на 2, 3 на 3, 2 на 4.
#
# 31    32         3    5    32        3    5    8    3
# 37    43         2    4    6         8    3    7    1
# 51    86        -1   64   -8
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.
#
# для не векторных  одноразмерных матриц

class Matrix:
    def __init__(self,m1):
        self.m1 = m1

    def __add__(self, other):
        res = []
        for i in range(len(self.m1)):
            c = []
            for j in range(len(self.m1[i])):
                c.append(self.m1[i][j]+ other.m1[i][j])
            res.append(c)
        return Matrix(res)

    def __str__(self): # для красивого вывода матриц 2х2, 3х3, 4х4 большие выведутся списком
        if len(self.m1) == 2:
            return f' {self.m1[0]}\n {self.m1[1]}'
        elif len(self.m1) == 3:
            return f' {self.m1[0]}\n {self.m1[1]}\n {self.m1[2]}'
        elif len(self.m1) == 4:
            return f' {self.m1[0]}\n {self.m1[1]}\n {self.m1[2]}\n {self.m1[3]}'
        else:
            return self.m1


m1 = [[1,2,3,4],[4,3,2,1],[9,8,7,6]]
m2 = [[11,12,13,14],[21,22,23,24],[1,2,3,4]]

mt1 = Matrix(m1)
mt2 = Matrix(m2)

print(mt1+mt2)




# 2. Реализовать проект расчёта суммарного расхода ткани на производство одежды. Основная сущность (класс) этого проекта — одежда, которая может иметь определённое название. К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.
#
#
class Odezhda:
    def __init__(self, razmer = None, rost = None):
        self.razmer = razmer
        self.rost = rost
    def palto(self):
        if self.razmer == None:
            return '0'
        else:
            return f'{round(self.razmer/6.5 + 0.5, 2)}'
    def kostum(self):
        if self.rost == None:
            return '0'
        else:
            return f'{round(2*self.rost + 0.3, 2)}'

try:
    v = int(input('размер: '))
except ValueError:
    v = None
try:
    h = float(input('рост в метрах: '))
except ValueError:
    h = None
if h > 2.2: # корректировка если рост введен в сантиметрах
    h = h/100
od = Odezhda(v, h)
print('пальто :', od.palto())
print('костюм: ', od.kostum())



# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка. В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число). В классе должны быть реализованы методы перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()). Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
#
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.

class Kletka:
    def __init__(self, strukt):
        self.kol_ya = 5
        self.s = strukt

    def __add__(self, other): #сложение
        return Kletka(self.s + other.s)
    def __sub__(self, other):# вычитание
        a = len(self.s) - len(other.s)
        if a <= 0:
            print('длинна первой клетки меньше второй')
        else:
            return Kletka(self.s[:a])
    def __mul__(self, other): # умножение
        res=''
        for i in self.s:
            res += i
            for j in other.s:
                res += j
        return Kletka(res)
    def __truediv__(self, other): # деление
        a=len(self.s)//len(other.s)
        res = ''
        if a == 1:
            return Kletka(self.s[0])
        elif a == 2:
            return Kletka(self.s[0] + other.s[0])
        else:
            for i in range(a // 2):
                res = res + self.s[i] + other.s[i]
            if a%2 == 0:
                return Kletka(res)
            else:
                return Kletka(res + self.s[a//2])

    def make_order(self):
        res = ''
        i = 0
        k =0
        for el in self.s:
            res = res + el
            i += 1
            if i == self.kol_ya:
                print(res)
                res = ''
                i=0
                k += self.kol_ya
        if k != len(self.s):
            print(self.s[k:])

kl1 = Kletka(input('введите код 1й клетки: '))
kl2 = Kletka(input('введите код 2й клетки: '))

a=kl1+kl2
print('сложение:')
a.make_order()

b = kl1 - kl2
print('вычитание:')
b.make_order()

c = kl1 * kl2
print('умножение')
c.make_order()

d = kl1 / kl2
print('деление')
d.make_order()